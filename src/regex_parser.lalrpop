use crate::regex_ast::*;

grammar;

pub Regex = {
    Concatenation,
    <Concatenation> "|" <Regex> => Box::new(RegexAst::Or(<>)),
    () => Box::new(RegexAst::Epsilon),
};

Concatenation = {
    Repetition,
    Concatenation Repetition => Box::new(RegexAst::Concat(<>)),
};

Repetition = {
    Term,
    <Term> "*" => Box::new(RegexAst::Star(<>)),
    <Term> "+" => Box::new(RegexAst::Concat(Box::new(RegexAst::Star(<>.clone())), <>)),
    <Term> "?" => Box::new(RegexAst::Or(Box::new(RegexAst::Epsilon), <>)),
};

Term = {
    Atom,
    CharClass,
    "(" <Regex> ")" => <>,
};

Atom: Box<RegexAst> = {
    EscChar => Box::new(RegexAst::Literal(<>)),
    "." => Box::new(RegexAst::Any),
};

CharClass: Box<RegexAst> = {
    "[" <CharSet> "]" => Box::new(RegexAst::CharClass(false, <>)),
    "[" "^" <CharSet> "]" => Box::new(RegexAst::CharClass(true, <>)),
};

CharSet = {
    EscChar => vec![<>],
    <mut vec:CharSet> <a:EscChar> => {
        vec.push(a);
        vec
    },
    CharRange,
    <mut vec:CharSet> <range:CharRange> => {
        vec.extend(range);
        vec
    },
};

CharRange: Vec<char> = {
    <a:EscChar> "-" <b:EscChar> => (a..=b).collect(),
};

EscChar: char = {
    Char => <>.into(),
    //"\\" <s:SpecialChar> => s,
};

Char: char = {
    r"[A-z]" => <>.chars().next().unwrap(),
};


/*
SpecialChar: char = {
    "." => '.',
    "*" => '*',
    "+" => '+',
    "?" => '?',
    "|" => '|',
    "(" => '(',
    ")" => ')',
    "[" => '[',
    "]" => ']',
    "\\" => '\\',
    "n" => '\n',
};
*/




